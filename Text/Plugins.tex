\chapter{Plugin system}
\vspace{-10mm}

There was a need of image segmentation support in Dicom-Presenter. A few of FNSPE student are working on image segmentation algorhitms of MRI images. Therefore raised an idea to import these algorhitms into Dicom-Presenter. The best idea was to design a plugin system for importing segmentation algorhitms.

Plugin in computer sciences is an optional addition to some application. It is not usually distributed with application itself, but can be added by user according to his needs. An example of a plugin can be an additional python script to Gimp program which allows user to apply 'sepia effect' on his photos. According to the mentioned example, plugins can be written in another language than application itself. They obtain some new functionality to application.

All segmentation algorithms developed at FNSPE were written in C language due to its performance. Plugins in C language are compiled to a Dynamic-Link libraries and run-time loaded. A theory of C++ libraries and description of run-time loading libraries can be found in Section \ref{library}.

\section{Image segmentation algorithms}

\red{
Popsat algoritmy Kuby Louckeho a Radka Maci.\\
}

\section{Plugins system requirements}

It is needed to set rules for plugin libraries. Therafter, a library following these rules should be applicable in DicomPresenter. The first thing is to generalize what the libraries will need as an input and output. All three libraries made by FNSPE students required an image with designated segmentable area together with computational parameters as an input. The most reasonable way to insert computation parameters is to generate a GUI interface including required input elements. This chapter discusses plugins GUI construction done at the application runtime and its connection to the loaded plugin library. A plugin interface was considered to be as simple as possible - a key idea was to require a minimum of source code modifications in existing image segmentation libraries.

\section{Generating plugins GUI}

Dicom-Presenter's graphic user interface is builded with use of Qt framework. Objects of Qt library classes represent application control elements. The objects can be created and displayed at a runtime according to plugin needs. A mandatory question is which way to choose for plugin GUI description.

Qt library offers its own format of GUI description. There is a tool in Qt SDK\footnote{Qt Software Development Kit is a package for Qt based applications development. SDK includes library files together with a native development IDE.} which offers an interactive GUI creation. It produces a XML file which describes the GUI. A strong argument for using this solution is that Qt library offers native tools for processing generated GUI description files.

Another possible way is to declare own language for GUI description. Firstly, it was implemented easily: Lines in a description file were corresponding to GUI elements. First word of a line determined a type of an element. Other words on the line described element behaviour such as default value, minimum and maximum value or matching function in a library. The second step was a transformation to XML standards. The result was simillar to preceding option but distinctive in sytax and naming. 

It would seem that the first solution is more reasonable. No new language is declared, though existing Qt library standard is used. Unfortunately, the Qt library syntax was primarily supposed to be generated by automated tool. The XML code is too complicated to be written manually - there is too much required phrases in the code. Morover, GUI elements are described by class-names from Qt library - therefore, it is needed to know the Qt library to be able to write a description manually. The only option would be to generate GUI description by the Qt interactive tool. However, it is a complex tool, aimed to creating extensive GUI layouts for large applications. Unlike, segmentation algorithm plugins require only a few control elements (input fields and buttons). It seems more accessible for a programmer to follow a few rules declared in GUI description language created for Dicom-Presenter instead of following extensive number of rules attached to Qt GUI description language.

\subsection{Dicom-Presenter GUI description language}

The GUI description should determine types of control elements their layout in interface window. The language for Dicom-Presenter GUI description is supposed to be simple. For every numeric input field it is needed to know: a required variable type (integer or float), the minimal and maximal possible value, the default value, a parameter description. Passing char parameters was realised by a combobox element - all possible values are listed in a dropdown menu.

A numeric field is declared by a string:

\clist{<numinput type="..." min="..." max="..." default="..." name="..."/>}

Where \clist{type} determines a C/C++ type (integer of double), \clist{min}, \clist{max}, \clist{default} determine minimum, maximum and default value and \clist{name} determines a parameter description.

A combobox can be declared in a similar way like in (X)HTML:

\noindent \indent \clist{<combobox type="..." name="...">}\\
\indent \indent \clist{<option value="..." name="..."/>}\\
\indent \indent \clist{<option value="..." name="..."/>}\\
\indent \clist{</combobox>}

Where \clist{type} determines a variable type passed to a library. \clist{name} in \clist{combobox} tag is a text description of property. The \clist{name} property in \clist{option} tag is a text description of a \clist{value} which is passed to a library.

\section{Dynamically loading plugin functions}

Dicom-Presenter's image segmentation algorithms use individual parameters. Therefore, each main computational function in each plugin needs individual number and types of parameters. A C/C++ function located in dynamically loaded library is ran through a function pointer as seen on Listing \ref{sec:runtimeloading}. This pointer must have a fixed number and fixed types of parameters given at compiliation. Thus, it is not possible to call various functions with various sets of parameters from a dynamically loaded library. It is possible to run only a finite number of types of functions according to a set of given parameters. There were several solutions how to make the Dicom-Presenter plugin system variable enough to load and run previously unknown functions:

\begin{enumerate}
\item It is possible to pre-define sufficient number of function pointer types at a compilation time. Then, each Dicom-Presenter plugin must have input function of predefined type.
\item Another solution is based on a fact that a function pointer can have more parameters than targeted function. For example, a function pointer having five integer parameters can point to a function receiving only three integer parameters - the last two given parameters will be ignored. Therefore it would be possible to define function pointers with excessing number of float, integer and char parameters. A function pointer would be assigned to a function to fit the first couple of parameters and ignoring the rest.
\item Another applicable way is to allow only one-parameter requiring functions to be present in a plugin. If the algorithm would need more parameters, then appropriate functions settings these parameters would be ran. Parameters can be saved as global variables to be reachable by main computational function. This solution has a great advantage: It is possible to call the parameter setting functions simultaneously to user  manipulating with relevant GUI elements. Then, an instant feedback from the library could be present (checking for incompatible values). This solution was implemented but it seemed too restrictive for library design. 
\item Last option is inspired by passing command line arguments to a standard C/C++ application. C/C++ Main Function receives a pointer to an array of all arguments. As in this case a plugin library function can receive three pointers to three array types: pointer to int, pointer to double and pointer to char. The arrays can be of any length.
\end{enumerate}

At first the third option was used in implementation. Function setting algorithm parameters were called while setting parameters in GUI. But there were no real benefits of library response while setting GUI parameters. More than that the rules for plugins were too bounding. Therefore, the final version of plugins API were implemented using option 4.

\section{User Interaction in Image Segmentation plugins}

\red{
Popsat jak uzivatel musi nakreslit seminku krivky.\\
Popsat implementaci, jaka byla pouzita.\\
}