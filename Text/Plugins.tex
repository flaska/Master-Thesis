\chapter{Plugin system}
\vspace{-10mm}

There was a need of image segmentation support in Dicom-Presenter. A few of FNSPE student are working on image segmentation algorhitms of MRI images. Therefore raised an idea to import these algorhitms into Dicom-Presenter. The best idea was to design a plugin system for importing segmentation algorhitms.

Plugin in computer sciences is an optional addition to some application. It is not usually distributed with application itself, but can be added by user according to his needs. An example of a plugin can be an additional python script to Gimp program which allows user to apply 'sepia effect' on his photos. According to the mentioned example, plugins can be written in another language than application itself. They obtain some new functionality to application.

All segmentation algorithms developed at FNSPE were written in C language due to its performance. Plugins in C language are compiled to a Dynamic-Link libraries and run-time loaded. A theory of C++ libraries and description of run-time loading libraries can be found in Section \ref{library}.

\section{Image segmentation algorithms}

\red{
Popsat algoritmy Kuby Louckeho a Radka Maci.\\
}

\section{Plugins system requirements}

It is needed to set rules for plugin libraries. Every library following these rules should be automatically usable in DicomPresenter. The first thing is to generalize what the libraries will need as an input and output. All three libraries made by FNSPE students just needed a picture and few parameters as an input. The parameters can be inserted into text fields by a user. Therefore, there has to be an opportunity to generate these text fields dynamically while loading a plugin. A computing algorithm in a library is ran by a function call of some function in the library. This function receives the parameters inserted by the user.

All three algorithms receive input image only as a file path on a disk. Images in Dicom-Presenter which user can see are two-dimensional projections of a three-dimensional picture - they are not stored in a file but just in a memory. Therefore, it will be needed to save them into a file to be processed by a segmentation algorithm.

\red{
Pavel: Pridat informace o tom, ze pozadavky na plugin system byla dale jednoduchost implementace pluginu.\\
Pavel: Pridat zminku o tom, ze algoritmy maji parametry a je potreba umoznit nastavovani techto parametru.\\
}

\section{Generating plugins GUI}

Dicom-Presenter GUI is written with use of Qt framework. GUI elements are created as objects of Qt classes and assigned to existing GUI elements. Dicom-Presenter plugin API has to be prepared for various number of text and numeric input fields. Therefore it is mandatory to pass information about GUI appearance to Dicom-Presenter. The goal of this section is to find the must suitable way of plugin GUI description.

Qt library offers it's own way for GUI description. There's a tool in Qt SDK which offers an interactive GUI creation. It produces a XML file which describes the GUI. A strong argument for using this solution is that Qt library offers its own tools for loading these files.

Another possible way was to declare our own language for plugins GUI description. Firstly it was implemented easily: Lines in a description file were corresponding to GUI elements. First word of a line determined a type of an element. Other words on the line described element behaviour such as default value, minimum and maximum value or a corresponding function in a library. In a second step GUI description was improved according to modern standards and implemented in XML - in a simillar way like in previous case.

It would seem that the first solution is more reasonable. We don't declare some new language but we use an existing standard from Qt library. This is in many cases right way of thinking. Unfortunately the Qt library syntax was primarily supposed to be generated by their tool. Their XML code was too complicated to be written manually - there were too much required phrases in their code. Morover, GUI elements were described by their class-names in Qt library - so it would be needed to know Qt library to write description manually. The only option would be to generate the code by their interactive tool. Unfortunately the tool was still too complex and complicated, aimed to creating extensive GUI layouts for large applications. In our case we need just description of few numeric and text input fields and one or more buttons. It seemed much more easier for a programmer to just follow our few rules for GUI description instead of using Qt library's extensive standard.

As mentioned above, external libraries for image segmentation just need a few numeric input fields for giving computation parameters and then a filename of an input image. For a better flexibility of our plugin solution there were added an option for passing char-type parameters and a possibility to run more functions in a library.

For every numeric input field it is needed to know: a required variable type (integer or float), minimal and maximal possible value, default value, parameter description. Passing char parameters was realised by a combobox element. So it is needed to know all possible values, text description of values and an overall description of the property. 

The language for Dicom-Presenter GUI description is supposed to be simple. A numeric field is declared by a string:

\clist{<numinput type="..." min="..." max="..." default="..." name="..."/>}

Where \clist{type} determines a C/C++ type (integer of double), \clist{min}, \clist{max}, \clist{default} determine minimum, maximum and default value and \clist{name} determines a parameter description.

A combobox can be declared in a similar way like in (X)HTML:

\noindent \indent \clist{<combobox type="..." name="...">}\\
\indent \indent \clist{<option value="..." name="..."/>}\\
\indent \indent \clist{<option value="..." name="..."/>}\\
\indent \clist{</combobox>}

Where \clist{type} determines a variable type passed to a library. \clist{name} in \clist{combobox} tag is a text description of property. The \clist{name} property in \clist{option} tag is a text description of a \clist{value} which is passed to a library.


\begin{comment}
First idea was to use our own way to describe plugin GUI. The first version of plugins system used it's own primitive language. Lines in description file were corresponding to GUI elements. First word of a line determined a type of an element. Other words on the line described element behaviour such as default value, minimum and maximum value or a corresponding function in a library. This own language of GUI description was sufficient but it was unnecessary to force plugin programmer to use our own language. Instead it would be better to use some existing standard.

Other way how to describe a plugin GUI was to use XML language. XML is often use in computer science to pass information in an easily processable form. Moreover Qt library includes extended tools for XML processing.

Last option is to use Qt language for UI description. Qt library uses it's own form to describe application GUI - description is in a special file with a \clist{.ui} extension. It is a strong argument for this option that it is a native way for Qt library to use this langage. Qt library provides a utility for interactive GUI creating. 
\end{comment}



\section{Dynamically loading plugin functions}

Dicom-Presenter plugins can use different number of parameters. A C/C++ function from dynamically loaded library is ran through a pointer to the function as we saw in \ref{sec:runtimeloading}. This pointer must have a fixed number and fixed types of parameters given at compiliation. Thus, it is not possible to call any function which needs any set of parameters from a dynamically loaded library. It is possible to run only a finite number of types of functions according to a set of given parameters. There were several solutions how to make the Dicom-Presenter plugin system variable enough to load and run various functions:

\begin{enumerate}
\item It is possible to try to define sufficient number of function pointer types at a compilation time. Then set a rule that every Dicom-Presenter plugin can have input function only of predefined type.
\item Another solution is based on a fact that a function pointer can have more parameters than targeted function. For example a function pointer having five integer parameters can point to a function receiving only three integer parameters - the last two given parameters will be ignored. Therefore it would be possible to define function pointers with excessing number of float, integer and char parameters. A function pointer would be assigned to a function to fit with the first couple of parameters ignoring the rest.
\item Another way which seems applicable but still presuming too much conditions from a loaded plugin was too allow only one-parameter functions in the plugin. These functions would set parameters in a library as global variables. Before running a computation all functions setting some parameter would be ran. This solution has a great advantage: It is possible to call the functions to set parameters right when user is manipulating with relevant GUI elements. So, there can be a feedback from the library telling user he set some incompatible set of values. This solution was implemented at first but it seemed too restrictive for a library design. 
\item Last option is inspired by an obligatory passing command line arguments to a standard C/C++ application. C/C++ Main Function receives a pointer to an array of all arguments. As in this case a plugin library function can receive three pointers to three array types: pointer to int, pointer to double and pointer to char. The arrays can be of any length.
\end{enumerate}

At first the third option was used in implementation (See an example on encloced CD). Function setting algorithm parameters were called while setting parameters in GUI. But there were no real benefits of a library response while setting GUI parameters. More than that the rules for plugins were too bounding. So therefore, the final version of plugins API were implemented using option 4.
