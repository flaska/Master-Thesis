\chapter*{Compilation in C++}
\addcontentsline{toc}{chapter}{Compilation in C++}

Dicom-Presenter is a large application. It consists of 5.000 source-code lines and it uses six external libraries. Therefore, it is not easy to compile it. Compilation of such a large project should be divided into parts, then a linking process should be described somehow. Moreover, external libraries have to be compiled in a compatible configuration. This chapter's goal is to describe compilation process of larger projects.

\section*{Libraries}
\addcontentsline{toc}{section}{Libraries}
\label{library}

A C++ application usually isn't compiled all in one step. It is divided into smaller logic parts usually called libraries. These libraries are compiled individually and then they're linked into the executable at the end. The benefit is that if the source code of the application is changed it is not needed to recompile the whole application. While, only the library including the change is recompiled. 

There are two ways of linking a library into a final executable: static linking and dymanic linking.
\begin{itemize}
\item Static linking of a library means that all function of the library are copied into the executable. Firstly, a library's source code is compiled into a .lib file and then it is inserted as a whole into the executable file.
\item Dynamic linking of a library means that only the library's name and its function names are inserted into the executable. An executable code of the linked library is distributed together with the executable file in a standalone .dll file. When the application is ran the operating system has to load library's executable code into the application's virtual memory. While compiling a dynamic-link library the compiler produces also a .lib file. The executable is linked against this .lib file but the lib file contains only instructions to load machine code from .dll files.
\end{itemize}

In addition, there is one more way how to use dynamic-link libraries:

\begin{itemize}
\item Dynamic-link libraries can be also loaded manually during the application run. Windows API offers a set of functions for run-time loading functions from .dll libraries. This is useful for rarely used functions. They don't need to occupy memory space all the time an application is ran.
\end{itemize}

A concept of dynamic-link libraries shows its potential when applied on libraries which are used by multiple applications. Dynamic-link libraries are also called shared libraries. These are the advantages of using shared libraries:

\begin{itemize}
\item If a dynamic-link library is used by multiple applications it is enough to be loaded once in computer memory. Multiple applications can access library functions at the same time.
\item If a library needs to be updated, there's no need to recompile the applications using library as far as library's function declarations aren't changed.
\end{itemize}


\section*{Run-time loaded libraries}
\addcontentsline{toc}{section}{Run-time loaded libraries}
\red{
Co to znamena run-time loaded library?\\
Proc potrebujeme run-time loaded library? No kvuli pluginum.\\
}

\subsection*{Compilation}
\addcontentsline{toc}{subsection}{Compilation}

A run-time loaded \clist{.dll} library is very similar to an \clist{.exe} binary, but there is a function exports table in a \clist{.dll} library. Exported functions are accessible from outside of the library, functions not exported are private functions. Therefore, a compiler needs to know which functions have to be exported. There are two ways for declaring this: a \clist{dllexport} macro can be used or a \clist{Module Definition File} can be used. A \clist{Module Definition File} is a file including a list of exported functions using a very simple syntax. There is an example of a \clist{Module Definition File} in Listing \ref{DEF}. An example of using the \clist{dllexport} macro can be seen in Listing \ref{dllspec}. Placing the macro before a function definition is enough to tell a compiler to export the function.

\begin{lstlisting}[label=DEF,caption={A \clist{Module Definition File} of a library called ``Mathfuncs'' including a function called ``PrimeTest''.}]
LIBRARY   MATHFUNCS
EXPORTS
   PrimeTest	@1
\end{lstlisting}


\begin{lstlisting}[label=dllspec,caption={An example of exporting a function by using a \clist{dllexport} macro.},escapeinside={@}{@}]
#include <iostream>
#include <cmath>
#include "mathfuncs.h"

extern "C"{
	__declspec(dllexport) bool PrimeTest(int n){
	bool isPrime=true;
	for (int d=2;d<=sqrt((float)n);d++){
		if (n%d==0) isPrime=false;
	}
	return isPrime;
}
\end{lstlisting}

\subsection*{Loading}
\addcontentsline{toc}{subsection}{Loading}
\label{sec:runtimeloading}

\begin{lstlisting}[label=WinAPI,caption={An application loading a .dll library at runtime.},escapeinside={@}{@}]
#include <iostream>
#include <windows.h>

typedef bool PrimeTestFunction(int);

int main (){
	HINSTANCE LoadedLibrary;
	LoadedLibrary=LoadLibrary(TEXT("MathFuncs.dll"));
	if (LoadedLibrary!=NULL){
		FARPROC ProcessAdress;
		ProcessAdress=GetProcAddress(LoadedLibrary,"PrimeTest");
		PrimeTestFunction* _PrimeTestFunction=(PrimeTestFunction*)ProcessAdress;
		if(_PrimeTestFunction){
			std::cout << "23 is prime number:" << _PrimeTestFunction(23) << std::endl;
		}
		FreeLibrary(LoadedLibrary);
	}
}
\end{lstlisting}



\section*{C++ Standard Library in MS Visual Studio}
\addcontentsline{toc}{section}{C++ Standard Library in MS Visual Studio}
\label{standardlibrary}
C++ Standard Library\footnote{C++ Standard library is a C++ version of C Run-time library. Unfortunately both names are often confused.} is used in almost all C++ application. It provides communication with the operation system. It offers manipulation with standard input and output (stdio.h), memory allocation (stdlib.h), math functions (math.h), time related funtions (time.h), etc. If the library is used in application its header files are included in source code and the library is linked into executable file.

There are four different implementations of C++ Standard library in Microsoft Visual Studio compiler. The rule is that only one type of implementation can be linked into executable file. The problem is if multiple external libraries are used in one project. Every external library is compiled with use of some kind of Standard C++ library implementation. If we try to link an application against external libraries using different implementations of C++ Standard library we receive a linker error 2005 - already defined. This error arises because multiple versions of C++ Standard library are linked at the same time but they define the same functions.

Therefore, it is mandatory to distinguish implementations of C++ Standard library. All external libraries as well as all inner libraries has to be linked against the same version of C++ Standard library! Standard C++ library implementations differ according to use of dynamic or static linking and according to debug or release building. So, all used libraries has to use static or dynamic linking and all of them has to be builded in debug or release mode. Then, the final application can be linked. Therefore, if we use external libraries we often have to rebuild them to gain proper version of the library using required version of C++ Runtime library.

In addition to the problem explanation the Table \ref{standardlibrarytable} is included. It should help to resolve the purpose of problem when receiving linker eror 2005. 

\begin{table}
  \caption{A list of four build configurations using different implementation of C++ Standard Library.}
  \label{standardlibrarytable}
	\begin{tabular}{| l| l | l |}
	  \hline                       
	  Link type & Build mode & Library file \\
	  \hline
	  \hline                     
	  Static & Debug & LIBCPMTD.LIB\\
	  \hline
	  Static & Release & LIBCPMTD.LIB\\
	  \hline  
	  Dynamic & Debug & MSVCPRTD.LIB\\
	  \hline  
	  Dynamic & Release & MSVCPRT.LIB\\  
	  \hline  
	\end{tabular}
\end{table}


\section*{CMake}
\addcontentsline{toc}{section}{CMake}

As mentioned before, C++ projects are usually compiled in parts and then linked together at the end. So, the build process has to be described somehow. The description includes mainly information about:

\begin{itemize}
\item Grouping project files into project libraries.
\item Dependency on external libraries.
\item Description of custom build steps.
\end{itemize}

Microsoft Visual Studio uses its own format of build description accessible from its GUI. There is GNU Automake system for build decription on Unix systems. Since Dicom-Presenter was supposed to be a multi-platform application there was a need to find some system of build description applicable on both Windows and Unix systems. A reasonable solution is a use of CMake, because offers a platform-independent build description. CMake script describes a build tree as well as project dependencies. Then a CMake tool offers generating Visual Studio project for Windows OS or GNU automake files for Unix OS.

CMake is often use in OpenSource projects. It offers easy portability of an application between Win32 and Unix based systems. Both plib and dcmtk libraries used in Dicom-Presenter use CMake for build scripts generation. According to Section \ref{standardlibrary} both libraries needs to be compiled before compiling Dicom-Presenter.

\subsection*{CMake syntax}
\addcontentsline{toc}{subsection}{CMake syntax}

Following section describes CMake syntax necessary to build simple applications. 

A CMake build description is always written in a file named \clist{CMakeLists.txt} and placed in project root directory. At the beginning of the file there has to be preamble requesting CMake of newer version than declared: \clist{cmake\-\_minimum\-\_required\-(VERSION ...)}.

When compiling from a command line with use of gcc or g++ it is necessary to mention where can compiler find header files from external libraries and where can linker find .lib files from external libraries. CMake uses commands \texttt{include\-\_directories\-("...")} and \texttt{link\-\_directories\-("...")} for defining paths to libraries.

As mentioned in Section \ref{library}, C++ applications are firstly compiled in parts into internal libraries and then linked together. A library compilation is in CMake declared by command \texttt{add\-\_library\-(library1 library1.cpp library1.h ...)}. The first parameter is a name of the library. It is the name of the output file, but moreover it is the name under which CMake remembers this library. The other parameters make a list of files which will be compiled as the library.

If a library depends on external libraries a command \texttt{target\-\_link\-\_libraries\-(library1 lib1 lib2)} defines the dependencies. The first parameter is the name of the internal library. The other parameters are filenames of external libraries.

It is possible to add custom build commands with statement: {\tt add\-\_custom\-\_command\-(COMMAND command1 OUTPUT outputfile1)}. A shell command follows a \clist{COMMAND} macro. It can by any Linux or Windows console command including a program call. The second argument placed after \clist{OUTPUT} macro is a label for an output file generated by the command. Then, this file can be used for building later in CMake script. It can be a source-code file, resource file, library, etc.




\definecolor{LightGray}{RGB}{245,245,245}
\definecolor{LightRed}{RGB}{150,150,150}
\definecolor{LightGreen}{RGB}{0,0,0}
\definecolor{LightBlue}{RGB}{100,100,100}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\tt\small\color{LightBlue},          % print whole listing small
keywordstyle=\small\color{black},	% bold black keywords
identifierstyle=\small\color{LightBlue},           % nothing happens
commentstyle=\small\color{Rhodamine}, % white comments
stringstyle=\ttfamily,      % typewriter type for strings
showstringspaces=false,     % no special string spaces
numbers=left,                   % where to put the line-numbers
numberstyle=\tiny\tt,      % the size of the fonts that are used for the line-numbers
%stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
%backgroundcolor=\color{LightGray},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,			% adds a frame around the code
tabsize=3,	                % sets default tabsize to 2 spaces
%captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title={Zdrojovy kod},                 % show the filename of files included with \lstinputlisting; also try caption instead of title
%escapeinside={\%*}{*)}          % if you want to add a comment within your code
escapechar=!,
}

\begin{lstlisting}[caption={Skript systému Cmake pro překlad programu Dicom Presenter}, language=make, morekeywords={cmake_minimum_required, project, set, include_directories, link_directories, add_custom_command, OUTPUT, COMMAND, add_library, target_link_libraries, ADD_EXECUTABLE},keywordstyle=\small\color{LightGreen}]
cmake_minimum_required(VERSION 2.8)
project (dicom-presenter)

set (Qt_LIBRARY_PATH /usr/share/qt4)
set (Cg_LIBRARY_PATH /usr)
...

include_directories (!\redlist{``./src''}!)
include_directories (!\redlist{``\${Qt\_LIBRARY\_PATH}/include''}!)
include_directories (!\redlist{``\${Cg\_LIBRARY\_PATH}/include''}!)
...

link_directories (!\redlist{``\${Qt\_LIBRARY\_PATH}/lib''}!)
link_directories (!\redlist{``\${Cg\_LIBRARY\_PATH}/lib''}!)
...

add_custom_command (OUTPUT moc/moc_mainWindow.cpp COMMAND moc src/mainWindow.h > moc/moc_mainWindow.cpp)
add_library (mainWindow src/mainWindow.cpp moc/moc_mainWindow.cpp src/mainWindow.h)
target_link_libraries (mainWindow QtGui GLEW)

add_library (glImage src/glObjects/glImage.cpp src/glObjects/glImage.h)
target_link_libraries (glImage QtOpenGL QtCore)

...

ADD_EXECUTABLE (dp src/main.cpp)
target_link_libraries (dicom-presenter mainWindow glImage ...)
\end{lstlisting}



