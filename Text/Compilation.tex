\chapter{Project Build Environment}
\vspace{-10mm}
\label{compilationchapt}
Compilation of larger projects such as Dicom-Presenter should be divided into parts and the linking process should be described in some form. Moreover, external libraries need to be compiled in a compatible configuration. This Chapter sets a goal to describe compilation process of larger projects.

\section{Application Modules}

\label{library}

A C++ application is not usually compiled entirely in one step. It is divided into smaller logic parts known as modules. These parts are compiled individually and then they are linked into the executable at the end. The benefit is that, if the source code of the application is changed, it is not needed to recompile the whole application - only the modules including the affected source code are recompiled. 


\section{CMake}

CMake\cite{cmake_home} allows description of the compilation process. It specifies mainly:

\begin{itemize}
\item Grouping project files into project libraries.
\item Dependency on external libraries.
\item Description of custom build steps.
\end{itemize}

The most common tools for automated compilation are GNU Automake on Linux OS and Microsoft Visual Studio projects on Windows OS\cite{msvcompilation}. CMake is more general tool, it allows for the generation of both: GNU Automake files and Microsoft Visual Studio project. Since Dicom-Presenter was supposed to be a multi-platform application, CMake was used for automating the compilation process.

CMake is often used in open-source projects. Both plib\citesec{plibhome} and dcmtk\citesec{dcmtkhome} libraries, used in Dicom-Presenter, were equipped with a CMake for script.

\subsection{CMake Syntax}


The following section describes CMake syntax necessary to build simple applications. 

A CMake build description is always written in a file named \clist{CMakeLists.txt} and placed in the project root directory. At the beginning of the file there has to be preamble requesting CMake of newer version than declared: \clist{cmake\-\_minimum\-\_required\-(VERSION ...)}.

When compiling from a command line with use of gcc or g++ it is necessary to mention where the compiler can find header files from external libraries and where the linker can find .lib files from external libraries. CMake uses commands \texttt{include\-\_directories\-("...")} and \texttt{link\-\_directories\-("...")} for defining paths to libraries.

As mentioned in Section \ref{library}, C++ applications are firstly compiled in parts into internal libraries and then linked together. A library compilation is in CMake declared by command \texttt{add\-\_library\-(library1 library1.cpp library1.h ...)}. The first parameter is the name of the library. It is the name of the output file, but moreover it is also the name under which CMake remembers this library. The other parameters make a list of files which will be compiled as the library.

If a library depends on external libraries a command \texttt{target\-\_link\-\_libraries\-(library1 lib1 lib2)} defines the dependencies. The first parameter is the name of the internal library. The other parameters are filenames of external libraries.

It is possible to add custom build commands with statement: {\tt add\-\_custom\-\_command\-(COMMAND command1 OUTPUT outputfile1)}. A shell command follows a \clist{COMMAND} macro. It can be any Linux or Windows console command including a program call. The second argument placed after \clist{OUTPUT} macro is a label for an output file generated by the command. Then, this file can be used later on in the CMake script. It can be a source-code file, resource file, library, etc.




\definecolor{LightGray}{RGB}{245,245,245}
\definecolor{LightRed}{RGB}{150,150,150}
\definecolor{LightGreen}{RGB}{0,0,0}
\definecolor{LightBlue}{RGB}{100,100,100}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\tt\small\color{LightBlue},          % print whole listing small
keywordstyle=\small\color{black},	% bold black keywords
identifierstyle=\small\color{LightBlue},           % nothing happens
commentstyle=\small\color{Rhodamine}, % white comments
stringstyle=\ttfamily,      % typewriter type for strings
showstringspaces=false,     % no special string spaces
numbers=left,                   % where to put the line-numbers
numberstyle=\tiny\tt,      % the size of the fonts that are used for the line-numbers
%stepnumber=2,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
%backgroundcolor=\color{LightGray},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,			% adds a frame around the code
tabsize=3,	                % sets default tabsize to 2 spaces
%captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title={Zdrojovy kod},                 % show the filename of files included with \lstinputlisting; also try caption instead of title
%escapeinside={\%*}{*)}          % if you want to add a comment within your code
escapechar=!,
}

\begin{lstlisting}[caption={CMake script for application compilation.}, language=make, morekeywords={cmake_minimum_required, project, set, include_directories, link_directories, add_custom_command, OUTPUT, COMMAND, add_library, target_link_libraries, ADD_EXECUTABLE},keywordstyle=\small\color{LightGreen}]
cmake_minimum_required(VERSION 2.8)
project (dicom-presenter)

set (Qt_LIBRARY_PATH /usr/share/qt4)
set (Cg_LIBRARY_PATH /usr)
...

include_directories (!\redlist{``./src''}!)
include_directories (!\redlist{``\${Qt\_LIBRARY\_PATH}/include''}!)
include_directories (!\redlist{``\${Cg\_LIBRARY\_PATH}/include''}!)
...

link_directories (!\redlist{``\${Qt\_LIBRARY\_PATH}/lib''}!)
link_directories (!\redlist{``\${Cg\_LIBRARY\_PATH}/lib''}!)
...

add_custom_command (OUTPUT moc/moc_mainWindow.cpp COMMAND moc src/mainWindow.h > moc/moc_mainWindow.cpp)
add_library (mainWindow src/mainWindow.cpp moc/moc_mainWindow.cpp src/mainWindow.h)
target_link_libraries (mainWindow QtGui GLEW)

add_library (glImage src/glObjects/glImage.cpp src/glObjects/glImage.h)
target_link_libraries (glImage QtOpenGL QtCore)

...

ADD_EXECUTABLE (dp src/main.cpp)
target_link_libraries (dicom-presenter mainWindow glImage ...)
\end{lstlisting}

\section{Libraries}
Some parts of application's source code, which could be used in other programs, can be compiled into reusable units - libraries. C++ distinguishes two concepts of libraries: static-link and dynamic-link libraries:

\begin{itemize}
\item Static linking of a library means that all functions of the library are copied into the executable. Firstly, a library's source code is compiled into a .lib file and then it is inserted as a whole into the executable file.
\item Dynamic linking of a library means that only the library's name and its function names are inserted into the executable. An executable code of the linked library is distributed together with the executable file in a standalone .dll file. When the application is run the operating system has to load the library's executable code into the application's virtual memory. While compiling a dynamic-link library the compiler produces also a .lib file. The executable is linked against this .lib file but the lib file contains only instructions to load machine code from .dll files.
\end{itemize}

The concept of dynamic-link libraries shows its potential when applied to libraries that are used by multiple applications. Dynamic-link libraries are also called shared libraries. These are the advantages of using shared libraries:

\begin{itemize}
\item If a dynamic-link library is used by multiple applications it is enough to be loaded once in computer memory. Multiple applications can access library functions at the same time.
\item If a library needs to be updated, there's no need to recompile the applications using the library as long as the library's function declarations are not changed.
\end{itemize}


\section{Run-time Loaded Libraries}

Besides linking against a dynamic-link library, C++ environment offers a run-time loading of a shared library. A module containing the required function is loaded into the computer memory by calling WinAPI functions. Run-time loading is useful for modules that are used infrequently. Unlike compilation-time linking, the run-time loaded modules do not need to be stored in the computer memory all the application run-time. The modules can be loaded only if used and then removed from the computer memory.

A disadvantage of run-time library loading is the amount of necessary declarations and function calls to be undertaken, before a module is loaded.

\subsection{Compilation of Run-time Loaded Libraries}


A run-time loaded \clist{.dll} library is very similar to an \clist{.exe} binary, but there is a function exports table in a \clist{.dll} library\cite{msdn}. Exported functions are accessible from outside of the library, functions not exported are private functions. Therefore, a compiler needs to know which functions have to be exported. There are two ways for declaring this: a \clist{dllexport} macro can be used or a \clist{Module Definition File} can be used. A \clist{Module Definition File} is a file including a list of exported functions using a very simple syntax. There is an example of a \clist{Module Definition File} in Listing \ref{DEF}. An example of using the \clist{dllexport} macro can be seen in Listing \ref{dllspec}. Placing the macro before a function definition is enough to tell a compiler to export the function.

\begin{lstlisting}[label=DEF,caption={A \clist{Module Definition File} of a library called ``Mathfuncs'' including a function called ``PrimeTest''.}]
LIBRARY   MATHFUNCS
EXPORTS
   PrimeTest	@1
\end{lstlisting}


\begin{lstlisting}[label=dllspec,caption={An example of exporting a function by using a \clist{dllexport} macro.},escapeinside={@}{@}]
#include <iostream>
#include <cmath>
#include "mathfuncs.h"

extern "C"{
	__declspec(dllexport) bool PrimeTest(int n){
	bool isPrime=true;
	for (int d=2;d<=sqrt((float)n);d++){
		if (n%d==0) isPrime=false;
	}
	return isPrime;
}
\end{lstlisting}

The function \clist{PrimeTest} (Listing \ref{dllspec}) will be accessible from outside of the library.

\subsection{Run-time Library Loading}

\label{sec:runtimeloading}

Functions from run-time loaded libraries are accessed through function pointers\cite{msdn}. Therefore, a function pointer of a given type must be declared at the time of compilation. The type of the function pointer denotes which input parameters are passed to the function and which variable type will be returned by the function. C/C++ language does not offer type definitions at the runtime, therefore the type of the function pointer must be defined at the compilation time. The Listing \ref{runtime} includes a function type declaration at line \ref{lst:typedef}.

Before the desired function from the external library can be accessed, the library module must be loaded into the RAM memory. The library is loaded by calling a \clist{LoadLibrary} function from WinAPI, besides, Qt library offers \clist{QLibrary} class which encapsulates platform-dependent function calls.

After loading the library into the computer memory, a specific memory address of the accessed function must be obtained. Owing to the compilation time function export, the WinAPI or Qt library is able to acquire the exact address of the function. A \clist{GetProcAddress} function from WinAPI or \clist{QLibrary::resolve} function from Qt library can be used (line \ref{lst:getproc} on Listing \ref{runtime}).

Then, after assigning the obtained address to the function pointer, the accessed function can be called at any time until unloading the library from the computer memory (lines \ref{lst:pointer1}, \ref{lst:pointer2} and \ref{lst:pointer3} on Listing \ref{runtime}).

\begin{lstlisting}[label=runtime,caption={An application loading a .dll library at runtime.},escapeinside={@}{@}]
#include <iostream>
#include <windows.h>

@\label{lst:typedef}@typedef bool PrimeTestFunction(int);

int main (){
	HINSTANCE LoadedLibrary;
	LoadedLibrary=LoadLibrary(TEXT("MathFuncs.dll"));
	if (LoadedLibrary!=NULL){
		FARPROC ProcessAdress;
		@\label{lst:getproc}@ProcessAdress=GetProcAddress(LoadedLibrary,"PrimeTest");
		@\label{lst:pointer1}@PrimeTestFunction* _PrimeTestFunction=(PrimeTestFunction*)ProcessAdress;
		if(_PrimeTestFunction){
		@\label{lst:pointer2}@	std::cout << "23 is prime number:" << _PrimeTestFunction(23) << std::endl;
		}
		@\label{lst:pointer3}@FreeLibrary(LoadedLibrary);
	}
}
\end{lstlisting}



\section{C++ Standard Library in MS Visual Studio}

\label{standardlibrary}
C++ Standard Library\footnote{C++ Standard library is a C++ version of C Run-time library. Unfortunately both names are often confused.} is used in almost all C++ application. It provides communication with the operation system. It offers manipulation with standard input and output (stdio.h), memory allocation (stdlib.h), math functions (math.h), time related functions (time.h), etc. If the library is used in application its header files are included in the source code and the library is linked into an executable file.

There are four different implementations of C++ Standard library in Microsoft Visual Studio compiler. The rule is that only one type of implementation can be linked into an executable file. The problem is if multiple external libraries are used in one project. Every external library is compiled with the use of some kind of Standard C++ library implementation. If we try to link an application against external libraries using different implementations of C++ Standard library we receive a linker error 2005 - already defined. This error arises because multiple versions of C++ Standard library are linked at the same time but they define the same functions.

Therefore, it is important to distinguish between implementations of C++ Standard library. All external libraries as well as all inner libraries have to be linked against the same version of C++ Standard library! Standard C++ library implementations differ according to use of dynamic or static linking and according to debug or release building. So, all used libraries have to use static or dynamic linking and all of them have to be built in debug or release mode. Then, the final application is able to be linked. Therefore, if we use external libraries we often have to rebuild them to gain the appropriate version of the library using required version of C++ Runtime library.

In addition to the problem explanation the Table \ref{standardlibrarytable} is included. It should help to resolve the purpose of problem when he linker error 2005 is received. 

\begin{table}
    \caption{A list of four build configurations using different implementation of C++ Standard Library.\label{standardlibrarytable}}
\begin{center}
	\begin{tabular}{| l| l | l |}
	  \hline                       
	  Link type & Build mode & Library file \\
	  \hline
	  \hline                     
	  Static & Debug & LIBCPMTD.LIB\\
	  \hline
	  Static & Release & LIBCPMTD.LIB\\
	  \hline  
	  Dynamic & Debug & MSVCPRTD.LIB\\
	  \hline  
	  Dynamic & Release & MSVCPRT.LIB\\  
	  \hline  
	\end{tabular}
\end{center}
\end{table}




