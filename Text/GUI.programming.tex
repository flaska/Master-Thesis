\chapter{Graphic User Interface Programming}
\vspace{-10mm}

A Graphic User Interface (GUI) is a name for a graphic output of an application used for controlling the application flow. An application's control elements layout together with the application's workflow have to be described in the source code. Each operation system offers its own library for control elements creation. Creating an application with use of this OS related library is quite complicated. Applications are controled inside theirs ``main loop''. Main loop is technicaly a while-loop running constantly and listening for OS messages. Then, inside the loop is decided which function has to be called. Programming of the main loop is too complicated. Besides, when OS related library is used all control elements has to be declared in several steps giving several parameters.

Therefore, ``application framework'' libraries arise. Frameworks are libraries which allow to describe user interface easily in fewer steps. Usually, there is no need for describing the application loop and control elements are created on significantly less source code lines.


\section{GUI programming without an application framework}
\label{noqt}

Development of GUI Windows applications is possible with Windows API. It is a name for a set of various APIs - communication interfaces for performing services. These communication interfaces offer manipulation with filesystem, devices and also creating graphic windows.

Most common parts of Windows API are:
\begin{itemize}
\item \clist{kernel32.dll}, which is needed for memory management, input/output, process and thread creation.
\item \clist{user32.dll} for creating GUI elements, such as windows, buttons, etc.
\item \clist{shell32.dll} which offers access to Windows command line
\item \clist{WinSock} to use network
\end{itemize}

Windows API in C++ is used as an ordinary library. It has to be included and linked, then it is possible to call certain functions in program code.

There is an example of simple GUI application on Listing \ref{WinAPI}. \clist{main} function is replaced by \clist{WinMain} function (line \ref{lst:WinMain}). Important part of \clist{WinMain} function is a program loop (line \ref{lst:ProgramLoop}). Windows applications usually run continuously and wait for user input. This is done by infinite program loop where we get system messages including user input. Program behaviour according to user input is here defined in function WndProc (line \ref{lst:WndProc}). There is a condition controller which decides what part of program will be executed.

\begin{lstlisting}[label=WinAPI,caption={An example of a simple application using Windows API for GUI rendering.},escapeinside={@}{@}]
#include <windows.h>
@\label{lst:WndProc}@LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

@\label{lst:WinMain}@int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
		WNDCLASSEX wc;
    HWND hwnd;
    MSG Msg;
    wc.lpfnWndProc = WndProc;    
...
    if(not RegisterClassEx(&wc)){
        MessageBox(NULL, TEXT("Window Registration Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }
    hwnd = CreateWindowEx(
...
		);
    ShowWindow(hwnd, nCmdShow);

@\label{lst:ProgramLoop}@    while(GetMessage(&Msg, NULL, 0, 0) > 0){
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
    return Msg.wParam;
}
\end{lstlisting}

\section{GUI Frameworks}
\label{guiframeworks}
Application frameworks are libraries designed to ease GUI application creating. Complicated widget declaration processes are encapsulated inside the library. Then, framework classes are used instead of calling OS related functions. The two most popular application frameworks now are Qt and GTK.

Both Qt and GTK are based on the same schema. All control elements are represented by library classes. The control elements can be easily added to application windows. Control functions describing application response to user actions are defined. Then the control elements and control functions are connected together.

A source code syntax of Qt library and GTK library is very similar. Examples of two identical applications using GTK and Qt can be found on Listings \ref{gtk} and \ref{qt}. Both applications create a simple window with a button inside. Clicking the button writes an console output. The button and window creation can be found on lines \ref{lst:gtkbuttonstart} - \ref{lst:gtkbuttonfinish} on Listing \ref{gtk} (GTK) and lines \ref{lst:qtbuttonstart} - \ref{lst:qtbuttonfinish} on Listing \ref{qt} (Qt). The process is very similar unlike Qt uses functions in its classes and GTK uses global functions. The command on lines \ref{lst:gtkconnect} (Listing \ref{gtk}) and \ref{lst:qtconnect} (Listing \ref{qt}) is used for setting up interaction between button click and proper function call. The main difference is that GTK allows connection to global function calls (line \ref{lst:gtkcall}, Listing \ref{gtk}), unlike Qt allows to call functions of object inheriting QObject class (line \ref{lst:gtkcall}, Listing \ref{qt}).

\begin{lstlisting}[label=gtk,caption={A sample application using GTK framework.},escapeinside={@}{@}]
@\label{lst:gtkcall}@static void message(GtkWidget *widget, gpointer data){
    cout << "Hello World!";
}
...
@\label{lst:gtkbuttonstart}@GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
GtkWidget *button = gtk_button_new_with_label ("Hello World");
GtkWidget *layout = gtk_fixed_new();
gtk_fixed_put(GTK_FIXED(layout), button);
@\label{lst:gtkbuttonfinish}@gtk_container_add(GTK_CONTAINER(window), layout);
@\label{lst:gtkconnect}@g_signal_connect (button, "clicked", G_CALLBACK (message), NULL);
\end{lstlisting}

\begin{lstlisting}[label=qt,caption={A sample application using GTK framework.},escapeinside={@}{@}]
@\label{lst:qtcall}@class callhandler : public QObject {
Q_OBJECT
public slots:
	void message () {
		cout << "Hello World!";
	}
}
...
@\label{lst:qtbuttonstart}@QWidget *window = new QWidget();
QPushButton *button = new QPushButton();
QLayout *layout = new QGridLayout();
layout->add(button);
@\label{lst:qtbuttonfinish}@window->setLayout(layout);
@\label{lst:qtconnect}@connect(button,SIGNAL(clicked()),callhandler,SLOT(message()));
\end{lstlisting}