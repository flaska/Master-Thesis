\chapter{Graphic User Interface Programming}
\vspace{-10mm}

A Graphic User Interface (GUI) has to be described in the source code - control elements layout and their interaction. Each operation system offers its own library for control elements creation. Creating an application with use of this OS related library is quite complicated. Applications are controlled inside theirs ``main loop''. Main loop is technically a while-loop running constantly and listening for OS messages. Then, inside the loop is decided which function has to be called. Programming of the main loop is too complicated. Besides, when OS related library is used, all control elements have to be declared in several steps giving several parameters.

Therefore, ``application framework'' libraries arise. Frameworks are libraries which allow a description of the user interface easily and in fewer steps. Usually, there is no need for describing the application loop and control elements are created on significantly fewer lines of source code.


\section{GUI Programming without an Application Framework}
\label{noqt}

Development of GUI application for Windows is possible with Windows API. This is the name given to a set of various APIs - communication interfaces for performing services. These communication interfaces offer manipulation with file-system, devices and also creating graphic windows.

Most common parts of Windows API are:
\begin{itemize}
\item \clist{kernel32.dll}, which is needed for memory management, input/output, process and thread creation.
\item \clist{user32.dll} for creating GUI elements, such as windows, buttons, etc.
\item \clist{shell32.dll} which offers access to Windows command line
\item \clist{WinSock} to use network
\end{itemize}

Windows API in C++ is used as an ordinary library. It has to be included and linked, afterwards it is possible to call certain functions in the program code.

There is an example of simple GUI application on Listing \ref{WinAPI}. \clist{main} function is replaced by \clist{WinMain} function (line \ref{lst:WinMain}). An important part of \clist{WinMain} function is a program loop (line \ref{lst:ProgramLoop}). If a user does not manipulate with the application, the application iterates through its main loop and waits for user input. As soon as some user action is received, the application has to recognise the message and perform appropriate action. Program behavior according to user input is here defined in function WndProc (line \ref{lst:WndProc}). There is a condition controller, which decides, which part of the program will be executed.

\begin{lstlisting}[label=WinAPI,caption={An example of a simple application using Windows API for GUI rendering.},escapeinside={@}{@}]
#include <windows.h>
@\label{lst:WndProc}@LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

@\label{lst:WinMain}@int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
		WNDCLASSEX wc;
    HWND hwnd;
    MSG Msg;
    wc.lpfnWndProc = WndProc;    
...
    if(not RegisterClassEx(&wc)){
        MessageBox(NULL, TEXT("Window Registration Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }
    hwnd = CreateWindowEx(
...
		);
    ShowWindow(hwnd, nCmdShow);

@\label{lst:ProgramLoop}@    while(GetMessage(&Msg, NULL, 0, 0) > 0){
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
    return Msg.wParam;
}
\end{lstlisting}

\section{GUI Frameworks}
\label{guiframeworks}
Application frameworks are libraries designed to ease GUI application creation. Complicated widget declaration processes are encapsulated inside the library. Then, framework classes are used instead of calling OS related functions. The two most popular application frameworks currently are Qt and GTK.

Both Qt and GTK are based on the same schema. All control elements are represented by library classes. The control elements can be easily added to application windows. Control functions describing application response to user actions are defined. Then the control elements and control functions are connected together.

Source code syntax of Qt library and GTK library is very similar. Examples of two identical applications using GTK and Qt can be found on Listings \ref{gtk} and \ref{qt}. Both applications create a simple window with a button inside. Clicking the button writes a console output. The button and window creation can be found on lines \ref{lst:gtkbuttonstart} - \ref{lst:gtkbuttonfinish} on Listing \ref{gtk} (GTK) and lines \ref{lst:qtbuttonstart} - \ref{lst:qtbuttonfinish} on Listing \ref{qt} (Qt). The process is very similar unlike Qt uses functions in its classes and GTK uses global functions. The command on lines \ref{lst:gtkconnect} (Listing \ref{gtk}) and \ref{lst:qtconnect} (Listing \ref{qt}) is used for setting up interaction between button click and proper function call. The main difference is that GTK allows connection to global function calls (line \ref{lst:gtkcall}, Listing \ref{gtk}), unlike Qt allows calling functions of object inheriting QObject class (line \ref{lst:gtkcall}, Listing \ref{qt}).

\begin{lstlisting}[label=gtk,caption={A sample application using GTK framework.},escapeinside={@}{@}]
@\label{lst:gtkcall}@static void message(GtkWidget *widget, gpointer data){
    cout << "Hello World!";
}
...
@\label{lst:gtkbuttonstart}@GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
GtkWidget *button = gtk_button_new_with_label ("Hello World");
GtkWidget *layout = gtk_fixed_new();
gtk_fixed_put(GTK_FIXED(layout), button);
@\label{lst:gtkbuttonfinish}@gtk_container_add(GTK_CONTAINER(window), layout);
@\label{lst:gtkconnect}@g_signal_connect (button, "clicked", G_CALLBACK (message), NULL);
\end{lstlisting}

\begin{lstlisting}[label=qt,caption={A sample application using GTK framework.},escapeinside={@}{@}]
@\label{lst:qtcall}@class callhandler : public QObject {
Q_OBJECT
public slots:
	void message () {
		cout << "Hello World!";
	}
}
...
@\label{lst:qtbuttonstart}@QWidget *window = new QWidget();
QPushButton *button = new QPushButton();
QLayout *layout = new QGridLayout();
layout->add(button);
@\label{lst:qtbuttonfinish}@window->setLayout(layout);
@\label{lst:qtconnect}@connect(button,SIGNAL(clicked()),callhandler,SLOT(message()));
\end{lstlisting}