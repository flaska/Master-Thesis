\chapter*{GUI Applications Programming}
\addcontentsline{toc}{chapter}{GUI Applications Programming}
\vspace{-10mm}

\red{
Co je to GUI?\\
}

\section*{Windows API}
\addcontentsline{toc}{section}{Windows API}

Development of GUI Windows applications is possible with Windows API. It is a name for a set of various APIs - communication interfaces for performing services. These communication interfaces offer manipulation with filesystem, devices and also creating graphic windows.

Most common parts of Windows API are:
\begin{itemize}
\item \clist{kernel32.dll}, which is needed for memory management, input/output, process and thread creation.
\item \clist{user32.dll} for creating GUI elements, such as windows, buttons, etc.
\item \clist{shell32.dll} which offers access to Windows command line
\item \clist{WinSock} to use network
\end{itemize}

Windows API in C++ is used as an ordinary library. It has to be included and linked, then it is possible to call certain functions in program code.

There is an example of simple GUI application on Listing \ref{WinAPI}. \clist{main} function is replaced by \clist{WinMain} function (line \ref{lst:WinMain}). Important part of \clist{WinMain} function is a program loop (line \ref{lst:ProgramLoop}). Windows applications usually run continuously and wait for user input. This is done by infinite program loop where we get system messages including user input. Program behaviour according to user input is here defined in function WndProc (line \ref{lst:WndProc}). There is a switch controller which decides what part of program will be executed.

\begin{lstlisting}[label=WinAPI,caption={An example of a simple application using Windows API for GUI rendering.},escapeinside={@}{@}]
#include <windows.h>
@\label{lst:WndProc}@LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

@\label{lst:WinMain}@int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
		WNDCLASSEX wc;
    HWND hwnd;
    MSG Msg;
    wc.lpfnWndProc = WndProc;    
...
    if(not RegisterClassEx(&wc)){
        MessageBox(NULL, TEXT("Window Registration Failed!"), TEXT("Error!"), MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }
    hwnd = CreateWindowEx(
...
		);
    ShowWindow(hwnd, nCmdShow);

@\label{lst:ProgramLoop}@    while(GetMessage(&Msg, NULL, 0, 0) > 0){
        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
    return Msg.wParam;
}
\end{lstlisting}

\section*{GUI Frameworks}
\addcontentsline{toc}{section}{GUI Frameworks}

\red{
Proc bychom meli pouzivat nejaky framework? Vyrazne nam to usnadni praci. Nemusime resit smycku programu. Nemusime resit predavani zprav. Mame predem hotove tridy pro vsechny bezne uzivatelske prvky.\\
Jak nam pouziti frameworku usnadni praci? Ukazat dedictvi puvodnich trid a jejich prizpusobeni nasim pozadavkum.\\
Jak zajistim funkcnost programu, tj. kdyz uzivatel klikne tam a tam stane se to a to? Ukazat system signalu a slotu, ktery je v Qt i v GTK+. Ukazat eleganci a jednoduchost tohoto systemu.\\
}

%\subsection*{Qt Library}
%\addcontentsline{toc}{subsection}{Qt Library}

%Predstavit Qt strucne

\section*{Dicom-Presenter GUI model}
\addcontentsline{toc}{section}{Dicom-Presenter GUI model}

\clist{
Jak je tedy GUI resene v dicom presenteru? Ukazat settings panel, cwidget.\\
Mozna ukazat predavani uzivatelskych zprav z CWidget na workspaceManager, na CWorkspace, na CImage.\\
}